#!/usr/bin/env python3
import logging
import os
import sys
from pathlib import Path
from subprocess import check_call
from sys import stdin
from typing import Set

sys.path.append('{{.chezmoi.sourceDir}}/vendor/dotutil')
from util import (SetupExcetion, config_log, elevate_copy_file,  # noqa: E402
                  has_changed)

"""
在chezmoi更新.root文件后比较/root并应用到/root中
"""


class SyncRoot:
    def __init__(self, mapped_root: Path, rootlist_path: Path) -> None:
        self.mapped_root = mapped_root
        self.rootlist_path = rootlist_path
        self.log = logging.getLogger(__name__)

    def root_path(self, path) -> Path:
        return Path("/").joinpath(os.path.relpath(path, self.mapped_root)).absolute()

    def get_removed_mapped_files(self) -> Set[Path]:
        files = set()

        def readfiles(path):
            with open(path, 'r') as f:
                while line := f.readline():
                    file = Path(line.rstrip())
                    if not file.exists():
                        files.add(file)

        if self.rootlist_path.is_file():
            self.log.debug(f"found root list path {self.rootlist_path}")
            readfiles(self.rootlist_path)

        return files

    def save_rootlist(self):
        self.log.debug(
            f"saving current root list after apply to {self.rootlist_path}")
        count = 0
        with open(self.rootlist_path, 'w') as f:
            for path in self.mapped_root.rglob("*"):
                if path.is_file():
                    count += 1
                    f.write(f"{path}\n")
        self.log.debug(f"saved {count} files to {self.rootlist_path}")

    def remove_root_files(self):
        def rm(path: Path):
            if not path.exists():
                self.log.warning(f"not found root file {path}")
            elif path == Path("/"):
                raise SetupExcetion(f"invalid path {path}")

            if os.name == 'nt':
                cmd = f'gsudo del {path}'
            else:
                cmd = f"sudo rm -rf {path}"
            self.log.info(f"removing {path} with command: {cmd}")
            check_call(cmd.split())

        removed_files = self.get_removed_mapped_files()
        if not removed_files:
            self.log.debug("empty removed files")
            return

        logging.info(f"found removal files for root: {removed_files}")
        remove_all = False
        for path in removed_files:
            root_file = self.root_path(path)
            skipped = False
            if not remove_all:
                while True:
                    print(
                        f"whether to remove root file {root_file}?[remove, all-remove, skip]:", end='', flush=True)
                    line = stdin.readline().strip()
                    if "remove".startswith(line):
                        pass
                    elif "all-remove".startswith(line):
                        remove_all = True
                    elif "skip".startswith(line):
                        skipped = True
                    else:
                        print(f"unkown option: {line}")
                        continue
                    break
            if not skipped:
                rm(root_file)
            else:
                self.log.info(f"skipped remove {root_file}")

    def sync(self):
        diff_count = 0

        def copy_to_root(src: Path, dst: Path):
            nonlocal diff_count
            elevate_copy_file(src, dst)
            diff_count += 1

        def backup_at_first(path: Path):
            backup_path = path.with_name(f'{path.name}.backup')
            if backup_path.exists():
                return
            logging.info(
                f"backing up {path} to {backup_path} when first applied")
            elevate_copy_file(path, backup_path)

        self.remove_root_files()

        for path in self.mapped_root.rglob("*"):
            if path.is_file():
                root_path = self.root_path(path)
                if not root_path.exists():
                    copy_to_root(path, root_path)
                elif root_path.is_file():
                    if has_changed(path, root_path):
                        backup_at_first(root_path)
                        copy_to_root(path, root_path)
                else:
                    raise SetupExcetion(f"invalid file {root_path}")

        self.log.info(f"copied {diff_count} files from {self.mapped_root}")

        self.save_rootlist()


if __name__ == "__main__":
    # {{- if eq .chezmoi.os "windows" }}
    MAPPED_ROOT_DIR = Path(r'{{joinPath .chezmoi.homeDir ".root"}}')
    rootlist_path = Path(r'{{joinPath .chezmoi.cacheDir ".root"}}')
    # {{- else }}
    MAPPED_ROOT_DIR = Path('{{joinPath .chezmoi.homeDir ".root"}}')
    rootlist_path = Path('{{joinPath .chezmoi.cacheDir ".root"}}')
    # {{- end }}
    level = logging.INFO if '{{ has "--verbose" .chezmoi.args | or (has "-v" .chezmoi.args) | default "" }}' else logging.ERROR  # noqa: E501
    config_log(level=level)

    if MAPPED_ROOT_DIR.is_dir():
        try:
            SyncRoot(MAPPED_ROOT_DIR, rootlist_path).sync()
        except SetupExcetion as e:
            logging.error(f"{e}")
            exit(1)
    else:
        logging.warn(
            f"skipped apply. mapped root is not dir: {MAPPED_ROOT_DIR}")
